<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Three.js</title>
  </head>
  <body>
    <canvas id="c"></canvas>
    <div id="loading">
        <div class="progress"><div class="progressbar"></div></div>
      </div>
    
    <style>
        html, body {
           margin: 0;
           height: 100%;
        }
        #c {
           width: 100%;
           height: 100%;
           display: block;
        }
        #loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        }
        #loading .progress {
            margin: 1.5em;
            border: 1px solid white;
            width: 50vw;
        }
        #loading .progressbar {
            margin: 2px;
            background: white;
            height: 1em;
            transform-origin: top left;
            transform: scaleX(0);
        }
        </style>
        
  </body>
  <script type="importmap">
    {
      "imports": {
        "three": "./lib/three.module.js"
        
      }
    }
    </script>
<script type="module">
import * as THREE from 'three';
import { GUI } from './lib/lil-gui.module.min.js';
import { OrbitControls } from './lib/OrbitControls.js';
import { OBJLoader } from './lib/OBJLoader.js';
import {MTLLoader} from './lib/MTLLoader.js';


function main() {
    


	const canvas = document.querySelector( '#c' );
	const renderer = new THREE.WebGLRenderer( { antialias: true, canvas } );
    function resizeRendererToDisplaySize(renderer) {
      const canvas = renderer.domElement;
      const pixelRatio = window.devicePixelRatio;
      const width  = Math.floor( canvas.clientWidth  * pixelRatio );
      const height = Math.floor( canvas.clientHeight * pixelRatio );
      const needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
      }
      return needResize;
    }






	const fov = 75;
	const aspect = 2; // the canvas default
	const near = 0.1;
	const far = 5;
	const camera = new THREE.PerspectiveCamera( fov, aspect, near, far );
	camera.position.z = 3;

    camera.updateProjectionMatrix();
	const scene = new THREE.Scene();
  class MinMaxGUIHelper {

constructor( obj, minProp, maxProp, minDif ) {

  this.obj = obj;
  this.minProp = minProp;
  this.maxProp = maxProp;
  this.minDif = minDif;

}
get min() {

  return this.obj[ this.minProp ];

}
set min( v ) {

  this.obj[ this.minProp ] = v;
  this.obj[ this.maxProp ] = Math.max( this.obj[ this.maxProp ], v + this.minDif );

}
get max() {

  return this.obj[ this.maxProp ];

}
set max( v ) {

  this.obj[ this.maxProp ] = v;
  this.min = this.min; // this will call the min setter

}

}


const gui = new GUI();
gui.add(camera, 'fov', 1, 180);
const minMaxGUIHelper = new MinMaxGUIHelper( camera, 'near', 'far', 0.1 );
gui.add(minMaxGUIHelper, 'min', 0.1, 50, 0.1).name('near');
gui.add(minMaxGUIHelper, 'max', 0.1, 50, 0.1).name('far');

const controls = new OrbitControls( camera, canvas );
controls.target.set( 0, 1, 0 );
controls.update();

  
  {

const mtlLoader = new MTLLoader();
mtlLoader.load( './models/coffee_cup.mtl', ( mtl ) => {

  mtl.preload();
  const objLoader = new OBJLoader();
  objLoader.setMaterials( mtl );
  objLoader.load( './models/coffee_cup.obj', ( root ) => {
    scene.add( root );

  } );

} );

}

	const boxWidth = 1;
	const boxHeight = 1;
	const boxDepth = 1;
	const geometry = new THREE.BoxGeometry( boxWidth, boxHeight, boxDepth );

 
    const loadManager = new THREE.LoadingManager();
    const loader = new THREE.TextureLoader(loadManager);
    const texture = loader.load( './textures/cherry_planks.png' );
    
    // texture.colorSpace = THREE.SRGBColorSpace;
    let cubes = [];
    


    const material = new THREE.MeshPhongMaterial( { map: texture } );

    const materials = [
        new THREE.MeshPhongMaterial( {map: loadColorTexture('./textures/cherry_planks.png')}),
        new THREE.MeshPhongMaterial( {map: loadColorTexture('./textures/dirt.jpg')}),
        new THREE.MeshPhongMaterial( {map: loadColorTexture('./textures/oak_planks.png')}),
        new THREE.MeshPhongMaterial( {map: loadColorTexture('./textures/stone.png')}),
        new THREE.MeshPhongMaterial( {map: loadColorTexture('./textures/smooth_stone.png')}),
        new THREE.MeshPhongMaterial( {map: loadColorTexture('./textures/obsidian.png')})

    ]
        const loadingElem = document.querySelector('#loading');
    const progressBarElem = loadingElem.querySelector('.progressbar');
    loadManager.onLoad = () => {
    loadingElem.style.display = 'none';
    // const cube = new THREE.Mesh(geometry, material);
    // cube.position.x = 1.5
    // scene.add(cube);
    // cubes.push(cube);  // add to our list of cubes to rotate
    };

    loadManager.onProgress = (urlOfLastItemLoaded, itemsLoaded, itemsTotal) => {
    const progress = itemsLoaded / itemsTotal;
    progressBarElem.style.transform = `scaleX(${progress})`;
    };

    function loadColorTexture( path ) {
        const texture = loader.load( path );
        texture.colorSpace = THREE.SRGBColorSpace;
        console.log(`texture was loaded! ${path}`);
        return texture;

    }
	//renderer.render( scene, camera );
    
    function render(time) {
        time *= 0.001;  // convert time to seconds
        const canvas = renderer.domElement;
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        if (resizeRendererToDisplaySize(renderer)) {
        const canvas = renderer.domElement;
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
        }
        cubes.forEach((cube, ndx) => {
        const speed = .2 + ndx * .1;
        const rot = time * speed;
        cube.rotation.x = rot;
        cube.rotation.y = rot;
        });
            
        renderer.render(scene, camera);
        
        requestAnimationFrame(render);
    }
    const color = 0xFFFFFF;
    const intensity = 3;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(-1, 2, 4);
    scene.add(light);

    function makeInstance(geometry, color, x) {
        const material = new THREE.MeshPhongMaterial({color});
        
        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);
        
        cube.position.x = x;
        
        return cube;
    }

    class DegRadHelper {
  constructor(obj, prop) {
    this.obj = obj;
    this.prop = prop;
  }
  get value() {
    return THREE.MathUtils.radToDeg(this.obj[this.prop]);
  }
  set value(v) {
    this.obj[this.prop] = THREE.MathUtils.degToRad(v);
  }
}

    class StringToNumberHelper {
  constructor(obj, prop) {
    this.obj = obj;
    this.prop = prop;
  }
  get value() {
    return this.obj[this.prop];
  }
  set value(v) {
    this.obj[this.prop] = parseFloat(v);
  }
}

//     const wrapModes = {
//   'ClampToEdgeWrapping': THREE.ClampToEdgeWrapping,
//   'RepeatWrapping': THREE.RepeatWrapping,
//   'MirroredRepeatWrapping': THREE.MirroredRepeatWrapping,
// };
 
// function updateTexture() {
//   texture.needsUpdate = true;
// }
 
// const gui = new GUI();
// gui.add(new StringToNumberHelper(texture, 'wrapS'), 'value', wrapModes)
//   .name('texture.wrapS')
//   .onChange(updateTexture);
// gui.add(new StringToNumberHelper(texture, 'wrapT'), 'value', wrapModes)
//   .name('texture.wrapT')
//   .onChange(updateTexture);
// gui.add(texture.repeat, 'x', 0, 5, .01).name('texture.repeat.x');
// gui.add(texture.repeat, 'y', 0, 5, .01).name('texture.repeat.y');
// gui.add(texture.offset, 'x', -2, 2, .01).name('texture.offset.x');
// gui.add(texture.offset, 'y', -2, 2, .01).name('texture.offset.y');
// gui.add(texture.center, 'x', -.5, 1.5, .01).name('texture.center.x');
// gui.add(texture.center, 'y', -.5, 1.5, .01).name('texture.center.y');
// gui.add(new DegRadHelper(texture, 'rotation'), 'value', -360, 360)
//   .name('texture.rotation');

    requestAnimationFrame(render);
    

}

main();
</script>
</html>
